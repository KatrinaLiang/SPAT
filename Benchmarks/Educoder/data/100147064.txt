package step2;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class BestTeam {

	/********* Begin *********/

    public Long getBestTeam(int numbers, int[] abilities, int selectedNum, int distance){
        long max = 0;
        List<Long> resultList = new ArrayList<>();
        for (int i = 0; i < abilities.length; i++) {

            findNowBestTeam(i,abilities,distance,resultList,selectedNum);
        }
        for (long temp:resultList) {
            if (temp > max){
                max = temp;
            }
        }
        return max;
    }
    public void findNowBestTeam(int index, int[] abilities,int distance,List<Long> resultList,int selectedNum){
        List<Integer> abilitiesList = new ArrayList<>();
        abilitiesList.add(abilities[index]);

        int[] markOfAbilities = new int[abilities.length];
        markOfAbilities[index] = 1;
        //初始化left，right
        int left,right;
        if (index - distance >=0){
            left = index - distance;
        }
        else {
            left = 0;
        }
        if (index + distance < abilities.length){
            right = index + distance;
        }
        else {
            right = abilities.length-1 ;
        }
        findMax(left,right,abilitiesList,abilities,index,distance,selectedNum-1,markOfAbilities);
        long result = 1;
        for (int temp:abilitiesList) {
            result *= (long)temp;
        }
        resultList.add(result);

    }
    public void findMax(int left, int right, List<Integer> abilitiesList, int[] abilities, int index,int distance,int numbers,int[] markOfAbilities){
        //从left到right找最大的

        List<Student> studentList = new ArrayList<>();
        for (int i = left; i <= right ; i++) {
            if (markOfAbilities[i] == 1)
                continue;
            studentList.add(new Student(abilities[i],i));
        }
        Collections.sort(studentList);
        Student maxStudent = studentList.get(0);
        abilitiesList.add(maxStudent.ability);
        markOfAbilities[maxStudent.location] = 1;
        //更新范围
        if (maxStudent.location - distance < left){
            if (maxStudent.location - distance <0){
                left = 0;
            }
            else {
                left = maxStudent.location - distance;
            }
        }
        if (maxStudent.location + distance > right){
            if (maxStudent.location + distance >= abilities.length){
                right = abilities.length-1;
            }
            else {
                right = maxStudent.location + distance;
            }
        }
        numbers--;
        if (numbers != 0){
            findMax(left,right,abilitiesList,abilities,maxStudent.location,distance,numbers,markOfAbilities);
        }
    }
    class Student implements Comparable<Student>{
        int ability;
        int location;
        Student(int ability,int location){
            this.ability = ability;
            this.location = location;
        }


        @Override
        public int compareTo(Student student) {
            if (ability > student.ability)
                return -1;
            else if (ability == student.ability)
                return 0;
            return 1;
        }
    }

	/********* End *********/
}
