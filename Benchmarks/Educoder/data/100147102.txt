package step2;

public class BestTeam {

	/********* Begin *********/
    public static long currentMax = 0;//当前最优值
    public static int k;
    public static int d;
    
    public static void findMax(int curNum, int curIndex, int preIndex, long preSumValue, int[] arr) {
        if (curNum == k) {//参与乘积的个数为k
            if (preSumValue > currentMax) {//最优值替换
                currentMax = preSumValue;
            }
            return;
        }
        if (curNum + arr.length - curIndex < k) {//当前参与乘积的个数+剩余未考虑的元素个数 还不够k个，减枝
            return;
        }
        if (curIndex >= arr.length) {//数组越界了，减枝
            return;
        }
        if (curNum < k) {//实际上这个if不需要判断，能走到这一步，if这个条件一定是成立的。但是为了更好的理解，这里判断下。
            if (curIndex - preIndex <= d || preIndex == -1) {//不可忽略preIndex=-1的情况，这里容易遗漏
                findMax(curNum, curIndex + 1, preIndex, preSumValue, arr);//当前下标不参与运算
                findMax(curNum + 1, curIndex + 1, curIndex, preSumValue * arr[curIndex], arr);//当前下标参与运算
            } else {
                return;
            }
        }
    }

     public Long getBestTeam(int numbers, int[] abilities, int selectedNum, int distance){
		k = selectedNum;
        d = distance;
        int curNum = 0;//当前参与乘积的元素个数
        int curIndex = 0;//当前下标
        int preSumValue = 1;//上一次累积得到的最大值
        int preIndex = -1;//上一个参与乘积的元素下标
        findMax(curNum, curIndex, preIndex, preSumValue, abilities);
        return currentMax;
     }
	/********* End *********/
}
