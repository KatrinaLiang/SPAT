package step1;

public class GetScores {

	/********* Begin *********/
    public int getLostScores(int[] nums){
      
       sort(nums,0,nums.length-1);
       int[] n=new int[3];
       int count=0;
  		int j=1;
       for(int i=1;i<9997;i++){
          
          if((nums[i]-nums[i-1])>1){
                n[count++]=nums[i-1]+1;
                while((n[count-1]+1)!=nums[i]){
                    n[count]=n[count-1]+1;
                    count++;
                }
            }
            if(count>=3)break;
       }
          long c=0;
        for(int i=0;i<3;i++){
            int len=0,temp;
            temp=n[i];
            while(temp!=0){
                len++;
                temp/=10;
            }
            while(len!=0){
                c*=10;
                len--;
            }
            c+=n[i];
        }
       
        
       return (int)(c%11);
        
    }
    public void sort(int[] a,int low,int high){
         int start = low;
         int end = high;
         int key = a[low];
         
         
         while(end>start){
             //从后往前比较
             while(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
                 end--;
             if(a[end]<=key){
                 int temp = a[end];
                 a[end] = a[start];
                 a[start] = temp;
             }
             //从前往后比较
             while(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
                start++;
             if(a[start]>=key){
                 int temp = a[start];
                 a[start] = a[end];
                 a[end] = temp;
             }
         //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
         }
         //递归
         if(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1
         if(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个
     }
    
	
	

	/********* End *********/
}
